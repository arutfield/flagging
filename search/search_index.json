{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the CRWA Flagging Website Documentation! This site provides developers and maintainers information about the CRWA's flagging website, including information on: deploying the website, developing the website, using the website's code locally, and using the website's admin panel. Note This project is still currently under development. If you are interested in joining our team and contributing, read our project wiki .","title":"Home"},{"location":"about/","text":"About Flagging Website Of the many services that the CRWA provides to the greater Boston community, one of those is monitoring whether it is safe to swim and/or boat in the Charles River. The CRWA Flagging Program uses a system of color-coded flags to indicate whether or not the river's water quality is safe for boating at eleven boating locations between Watertown and Boston. Flag colors are based on E. coli and cyanobacteria (blue-green algae) levels; blue flags indicate suitable boating conditions and red flags indicate potential health risks. See the website's about page for more about the website functionality and how it relates to the flagging program's objectives. See the development history document for more information on how this project started and how we came to make the design decisions that you see here today. Code for Boston Code for Boston is the group that built the CRWA's flagging website. You can find a list of individual contributors here Code for Boston is a volunteer Civic Technology meetup. We are part of the Code for America Brigade network , and are made up of developers, designers, data geeks, citizen activists, and many others who use creative technology to solve civic and social problems. Charles River Via the EPA: The Charles River flows 80 miles from Hopkinton, Mass. to Boston Harbor. The Charles River is the most prominent urban river in New England. It is a major source of recreation and a readily-available connection to the natural world for residents of the Boston metropolitan area. The entire Charles River drains rain and melted snow from a watershed area of 310 square miles. Charles River Watershed Association (CRWA) The Charles River Watershed Association (\"CRWA\") was formed in 1965, the same year that Dirty Water peaked at #11 on the Billboard singles chart. Via the CRWA's website: CRWA is one of the country\u2019s oldest watershed organizations and has figured prominently in major cleanup and protection efforts. Since our earliest days of advocacy, we have worked with government officials and citizen groups from 35 Massachusetts watershed towns from Hopkinton to Boston. The EPA also relies on sample data collected by the CRWA to construct its report card.","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#flagging-website","text":"Of the many services that the CRWA provides to the greater Boston community, one of those is monitoring whether it is safe to swim and/or boat in the Charles River. The CRWA Flagging Program uses a system of color-coded flags to indicate whether or not the river's water quality is safe for boating at eleven boating locations between Watertown and Boston. Flag colors are based on E. coli and cyanobacteria (blue-green algae) levels; blue flags indicate suitable boating conditions and red flags indicate potential health risks. See the website's about page for more about the website functionality and how it relates to the flagging program's objectives. See the development history document for more information on how this project started and how we came to make the design decisions that you see here today.","title":"Flagging Website"},{"location":"about/#code-for-boston","text":"Code for Boston is the group that built the CRWA's flagging website. You can find a list of individual contributors here Code for Boston is a volunteer Civic Technology meetup. We are part of the Code for America Brigade network , and are made up of developers, designers, data geeks, citizen activists, and many others who use creative technology to solve civic and social problems.","title":"Code for Boston"},{"location":"about/#charles-river","text":"Via the EPA: The Charles River flows 80 miles from Hopkinton, Mass. to Boston Harbor. The Charles River is the most prominent urban river in New England. It is a major source of recreation and a readily-available connection to the natural world for residents of the Boston metropolitan area. The entire Charles River drains rain and melted snow from a watershed area of 310 square miles.","title":"Charles River"},{"location":"about/#charles-river-watershed-association-crwa","text":"The Charles River Watershed Association (\"CRWA\") was formed in 1965, the same year that Dirty Water peaked at #11 on the Billboard singles chart. Via the CRWA's website: CRWA is one of the country\u2019s oldest watershed organizations and has figured prominently in major cleanup and protection efforts. Since our earliest days of advocacy, we have worked with government officials and citizen groups from 35 Massachusetts watershed towns from Hopkinton to Boston. The EPA also relies on sample data collected by the CRWA to construct its report card.","title":"Charles River Watershed Association (CRWA)"},{"location":"admin/","text":"Admin Pages You can reach all admin pages by going to /admin and inputting a username and password. In development, the username is 'admin' and the password is 'password', but these should be set as config variables BASIC_AUTH_USERNAME and BASIC_AUTH_PASSWORD . Remember to log out by clicking the Logout button in the nav bar. Cyanobacteria Overrides There should be a link to this page in the admin navigation bar. On this page, one can add an override for a reach with a start time and end time, and if the current time is between those times then the reach will be marked as unsafe on the main website, regardless of the model data.","title":"Admin"},{"location":"admin/#admin-pages","text":"You can reach all admin pages by going to /admin and inputting a username and password. In development, the username is 'admin' and the password is 'password', but these should be set as config variables BASIC_AUTH_USERNAME and BASIC_AUTH_PASSWORD . Remember to log out by clicking the Logout button in the nav bar.","title":"Admin Pages"},{"location":"admin/#cyanobacteria-overrides","text":"There should be a link to this page in the admin navigation bar. On this page, one can add an override for a reach with a start time and end time, and if the current time is between those times then the reach will be marked as unsafe on the main website, regardless of the model data.","title":"Cyanobacteria Overrides"},{"location":"database/","text":"Database Project In-depth Guide We will be using PostgreSQL, a free, open-source database management system successor to UC Berkeley's Ingres Database but also support SQL language On OSX or Linux: We need to setup postgres database first thus enter into the bash terminals: brew install postgresql brew services start postgresql Explanation: We will need to install postgresql in order to create our database. With postgresql installed, we can start up database locally or in our computer. We use brew from homebrew to install and start postgresql services. To get homebrew, consult with this link: https://brew.sh/ To begin initialize a database, enter into the bash terminal: ```shell script export POSTGRES_PASSWORD= enter_password_here createdb -U enter_username_here flagging psql -U enter_username_here -d flagging -c \"DROP USER IF EXISTS flagging; CREATE USER flagging SUPERUSER PASSWORD '${POSTGRES_PASSWORD}'\" Explanation: Postgres password can be any password you choose. We exported your chosen postgres password into `POSTGRES_PASSWORD`, an environment variable, which is a variable set outside a program and is independent in each session. Next, we created a database called `flagging` using a username/rolename, which needs to be a Superuser or having all accesses of postgres. By default, the Superuser rolename can be `postgres` or the username for you OS. To find out, you can go into psql terminal, which we will explain below, and enter `\\du` to see all usernames. Finally, we add the database `flagging` using the env variable in which we save our password. You can see the results using the postgresql terminal which you can open by entering: psql Below are a couple of helpful commands you can use in the postgresql: \\q --to quit \\c database_name --to connect to database \\d --show what tables in current database \\du --show database users \\dt --show tables of current database To run the website, in the project directory `flagging` enter: ```shell script sh run_unix_dev.sh Running the bash script run_unix_dev.sh found in the flagging folder. Inside the scirpt, it defines environment variables FLASK_APP and FLASK_ENV which we need to find app.py. We also export the user input for offline mode, vault password, and postgres password for validation. Finally we initialize a database with a custom flask command flask init-db and finally run the flask application flask run . Regarding in how flask application connects to postgresql, database.py creates an object db = SQLAlchemy() which we will refer again in app.py to configure the flask application to support postgressql from .data import db db.init_app(app) . (We can import the db object beecause __init__.py make the object available as a global variable) Flask supports creating custom commands init-db for initializing database and update-db for updating database. init-db command calls init_db function from database.py and essentially calls execute_sql() which executes the sql file schema.sql that creates all the tables. Then calls update_database() which fills the database with data from usgs, hobolink, etc. update-db command primarily just udpates the table thus does not create new tables. Note: currently we are creating and deleting the database everytime the bashscript and program runs.","title":"Database"},{"location":"database/#database-project-in-depth-guide","text":"We will be using PostgreSQL, a free, open-source database management system successor to UC Berkeley's Ingres Database but also support SQL language On OSX or Linux: We need to setup postgres database first thus enter into the bash terminals: brew install postgresql brew services start postgresql Explanation: We will need to install postgresql in order to create our database. With postgresql installed, we can start up database locally or in our computer. We use brew from homebrew to install and start postgresql services. To get homebrew, consult with this link: https://brew.sh/ To begin initialize a database, enter into the bash terminal: ```shell script export POSTGRES_PASSWORD= enter_password_here createdb -U enter_username_here flagging psql -U enter_username_here -d flagging -c \"DROP USER IF EXISTS flagging; CREATE USER flagging SUPERUSER PASSWORD '${POSTGRES_PASSWORD}'\" Explanation: Postgres password can be any password you choose. We exported your chosen postgres password into `POSTGRES_PASSWORD`, an environment variable, which is a variable set outside a program and is independent in each session. Next, we created a database called `flagging` using a username/rolename, which needs to be a Superuser or having all accesses of postgres. By default, the Superuser rolename can be `postgres` or the username for you OS. To find out, you can go into psql terminal, which we will explain below, and enter `\\du` to see all usernames. Finally, we add the database `flagging` using the env variable in which we save our password. You can see the results using the postgresql terminal which you can open by entering: psql Below are a couple of helpful commands you can use in the postgresql: \\q --to quit \\c database_name --to connect to database \\d --show what tables in current database \\du --show database users \\dt --show tables of current database To run the website, in the project directory `flagging` enter: ```shell script sh run_unix_dev.sh Running the bash script run_unix_dev.sh found in the flagging folder. Inside the scirpt, it defines environment variables FLASK_APP and FLASK_ENV which we need to find app.py. We also export the user input for offline mode, vault password, and postgres password for validation. Finally we initialize a database with a custom flask command flask init-db and finally run the flask application flask run . Regarding in how flask application connects to postgresql, database.py creates an object db = SQLAlchemy() which we will refer again in app.py to configure the flask application to support postgressql from .data import db db.init_app(app) . (We can import the db object beecause __init__.py make the object available as a global variable) Flask supports creating custom commands init-db for initializing database and update-db for updating database. init-db command calls init_db function from database.py and essentially calls execute_sql() which executes the sql file schema.sql that creates all the tables. Then calls update_database() which fills the database with data from usgs, hobolink, etc. update-db command primarily just udpates the table thus does not create new tables. Note: currently we are creating and deleting the database everytime the bashscript and program runs.","title":"Database Project In-depth Guide"},{"location":"deployment/","text":"Deployment Note This guide is an instruction manual on how to deploy the flagging website to internet via Heroku. If you just want to run the website locally, you do not need Heroku. Instead, check out the development guide. The following tools are required to deploy the website: Heroku CLI Git Deploying for the first time Note In this section, the project name is assumed to be crwa-flagging . If you are deploying to another URL, such as crwa-flagging-staging or another personal domain, then replace each reference to crwa-flagging with that. If you've never deployed the app from your computer, follow these instructions. If you have not already done so, pull the repository to your computer, and then change your directory to it: git clone https://github.com/codeforboston/flagging.git cd ./flagging Additionally, make sure the VAULT_PASSWORD environment variable is set if it has not already been: Windows (CMD) set VAULT_PASSWORD = replace_me_with_pw OSX (Bash) export VAULT_PASSWORD = replace_me_with_pw Login to Heroku, and add Heroku as a remote repo using Heroku's CLI: heroku login heroku git:remote -a crwa-flagging Add the vault password as an environment variable to Heroku. Windows (CMD) heroku config:set VAULT_PASSWORD = %VAULT_PASSWORD% OSX (Bash) heroku config:set VAULT_PASSWORD = ${ VAULT_PASSWORD } Now deploy the app! git push heroku master Now try the following: heroku logs --tail If everything worked out, you should see the following at or near the bottom of the log: 2020-06-13T23:17:54.000000+00:00 app[api]: Build succeeded Note If you see instead see something like [...] State changed from starting to crashed , then read the rest of the output to see what happened. The most common error when deploying to production will be a RuntimeError: Unable to load the vault; bad password provided which is self-explanatory. Update the password, and the website will automatically attempt to redeploy. If you don't see that error, then try to self-diagnose. Go see the website for yourself! Subsequent deployments Heroku doesn't allow you to redeploy the website unless you create a new commit. Add some updates if you need to with git add . then git commit -m \"describe your changes here\" . Note In the very rare case you simply need to redeploy without making any changes to the site, in lieu of the above, simply do git commit --allow-empty -m \"redeploy\" . Once you have done that, Heroku will redeploy the site when you merge your working branch: git push heroku master Staging and Production Split It is recommended, though not required, that you have both \"staging\" and \"production\" environments for the website (see here for an explanation), and furthermore it is recommended you deploy to staging and play around with the website to see if it looks right before you ever deploy to production. Managing effectively two separate Heroku apps from a single repository requires a bit of knowledge about how git works. Basically what you're doing is connecting to two separate remote git repositories. The default remote repo is called heroku and it was created by Heroku's CLI. But since you now have two Heroku remote repositories, the Heroku CLI doesn't know what it's supposed to name the 2nd one. So you have to manually name it using git. Run the following command to create a staging environment if it does not already exist. heroku create crwa-flagging-staging Once it exists, add the staging environment as a remote; check to make sure all the remotes look right. The heroku remote should correspond with the production environment, and the staging remote should correspond with the staging environment you just created. git remote add staging https://git.heroku.com/crwa-flagging-staging.git git remote -v Tip The above command should output something like this: heroku https://git.heroku.com/crwa-flagging.git ( fetch ) heroku https://git.heroku.com/crwa-flagging.git ( push ) origin https://github.com/<your_github_username_here>/flagging.git ( fetch ) origin https://github.com/<your_github_username_here>/flagging.git ( push ) staging https://git.heroku.com/crwa-flagging-staging.git ( fetch ) staging https://git.heroku.com/crwa-flagging-staging.git ( push ) upstream https://github.com/codeforboston/flagging.git ( fetch ) upstream https://github.com/codeforboston/flagging.git ( push ) Now all of your heroku commands are going to require specifying the app, but the steps to deploy in staging are otherwise similar to the production deployment: Windows (CMD) heroku config:set --app crwa-flagging-staging VAULT_PASSWORD = %VAULT_PASSWORD% git push staging master heroku logs --app crwa-flagging-staging --tail OSX (Bash) heroku config:set --app crwa-flagging-staging VAULT_PASSWORD = ${ VAULT_PASSWORD } git push staging master heroku logs --app crwa-flagging-staging --tail Check out the website in the staging environment and make sure it looks right.","title":"Deployment"},{"location":"deployment/#deployment","text":"Note This guide is an instruction manual on how to deploy the flagging website to internet via Heroku. If you just want to run the website locally, you do not need Heroku. Instead, check out the development guide. The following tools are required to deploy the website: Heroku CLI Git","title":"Deployment"},{"location":"deployment/#deploying-for-the-first-time","text":"Note In this section, the project name is assumed to be crwa-flagging . If you are deploying to another URL, such as crwa-flagging-staging or another personal domain, then replace each reference to crwa-flagging with that. If you've never deployed the app from your computer, follow these instructions. If you have not already done so, pull the repository to your computer, and then change your directory to it: git clone https://github.com/codeforboston/flagging.git cd ./flagging Additionally, make sure the VAULT_PASSWORD environment variable is set if it has not already been: Windows (CMD) set VAULT_PASSWORD = replace_me_with_pw OSX (Bash) export VAULT_PASSWORD = replace_me_with_pw Login to Heroku, and add Heroku as a remote repo using Heroku's CLI: heroku login heroku git:remote -a crwa-flagging Add the vault password as an environment variable to Heroku. Windows (CMD) heroku config:set VAULT_PASSWORD = %VAULT_PASSWORD% OSX (Bash) heroku config:set VAULT_PASSWORD = ${ VAULT_PASSWORD } Now deploy the app! git push heroku master Now try the following: heroku logs --tail If everything worked out, you should see the following at or near the bottom of the log: 2020-06-13T23:17:54.000000+00:00 app[api]: Build succeeded Note If you see instead see something like [...] State changed from starting to crashed , then read the rest of the output to see what happened. The most common error when deploying to production will be a RuntimeError: Unable to load the vault; bad password provided which is self-explanatory. Update the password, and the website will automatically attempt to redeploy. If you don't see that error, then try to self-diagnose. Go see the website for yourself!","title":"Deploying for the first time"},{"location":"deployment/#subsequent-deployments","text":"Heroku doesn't allow you to redeploy the website unless you create a new commit. Add some updates if you need to with git add . then git commit -m \"describe your changes here\" . Note In the very rare case you simply need to redeploy without making any changes to the site, in lieu of the above, simply do git commit --allow-empty -m \"redeploy\" . Once you have done that, Heroku will redeploy the site when you merge your working branch: git push heroku master","title":"Subsequent deployments"},{"location":"deployment/#staging-and-production-split","text":"It is recommended, though not required, that you have both \"staging\" and \"production\" environments for the website (see here for an explanation), and furthermore it is recommended you deploy to staging and play around with the website to see if it looks right before you ever deploy to production. Managing effectively two separate Heroku apps from a single repository requires a bit of knowledge about how git works. Basically what you're doing is connecting to two separate remote git repositories. The default remote repo is called heroku and it was created by Heroku's CLI. But since you now have two Heroku remote repositories, the Heroku CLI doesn't know what it's supposed to name the 2nd one. So you have to manually name it using git. Run the following command to create a staging environment if it does not already exist. heroku create crwa-flagging-staging Once it exists, add the staging environment as a remote; check to make sure all the remotes look right. The heroku remote should correspond with the production environment, and the staging remote should correspond with the staging environment you just created. git remote add staging https://git.heroku.com/crwa-flagging-staging.git git remote -v Tip The above command should output something like this: heroku https://git.heroku.com/crwa-flagging.git ( fetch ) heroku https://git.heroku.com/crwa-flagging.git ( push ) origin https://github.com/<your_github_username_here>/flagging.git ( fetch ) origin https://github.com/<your_github_username_here>/flagging.git ( push ) staging https://git.heroku.com/crwa-flagging-staging.git ( fetch ) staging https://git.heroku.com/crwa-flagging-staging.git ( push ) upstream https://github.com/codeforboston/flagging.git ( fetch ) upstream https://github.com/codeforboston/flagging.git ( push ) Now all of your heroku commands are going to require specifying the app, but the steps to deploy in staging are otherwise similar to the production deployment: Windows (CMD) heroku config:set --app crwa-flagging-staging VAULT_PASSWORD = %VAULT_PASSWORD% git push staging master heroku logs --app crwa-flagging-staging --tail OSX (Bash) heroku config:set --app crwa-flagging-staging VAULT_PASSWORD = ${ VAULT_PASSWORD } git push staging master heroku logs --app crwa-flagging-staging --tail Check out the website in the staging environment and make sure it looks right.","title":"Staging and Production Split"},{"location":"shell/","text":"Flask Shell Documentation The shell is used to access app functions and data, such as Hobolink and USGS data and access to the database. Available Shell Functions and Variables db ( flask_sqlalchemy.SQLAlchemy ): The object used to interact with the Postgres database. get_live_hobolink_data ( (Optional[str]) -> pd.DataFrame ): Gets the Hobolink data table based on the given \"export\" name. See flagging_site/data/hobolink.py for details. get_live_usgs_data ( () -> pd.DataFrame ): Gets the USGS data table. See flagging_site/data/usgs.py for details. get_data ( () -> pd.DataFrame ): Gets the Hobolink and USGS data tables and returns a combined table. process_data ( (pd.DataFrame, pd.DataFrame) -> pd.DataFrame ): Combines the Hobolink and USGS tables. See flagging_site/data/model.py for details. To add more functions and variables, simply add an entry to the dictionary returned by the function make_shell_context() in flagging_site/app.py:creat_app() . Running the Shell First, open up a terminal at the flagging folder. Make sure you have Python 3 installed. Set up your environment with the following commands: python3 -m venv venv source venv/bin/activate python3 -m pip install -r requirements.txt Export the following environment variables like so: export VAULT_PASSWORD = replace_me_with_pw export FLASK_APP = flagging_site:create_app export FLASK_ENV = development Finally, start the Flask shell: flask shell And you should be good to go! The functions listed above should be available for use. See below for an example. Example: Export Hobolink Data to CSV Here we assume you have already started the Flask shell. This example shows how to download the Hobolink data and save it as a CSV file. >>> hobolink_data = get_live_hobolink_data () >>> hobolink_data . to_csv ( 'path/where/to/save/my-CSV-file.csv' )","title":"Shell"},{"location":"shell/#flask-shell-documentation","text":"The shell is used to access app functions and data, such as Hobolink and USGS data and access to the database.","title":"Flask Shell Documentation"},{"location":"shell/#available-shell-functions-and-variables","text":"db ( flask_sqlalchemy.SQLAlchemy ): The object used to interact with the Postgres database. get_live_hobolink_data ( (Optional[str]) -> pd.DataFrame ): Gets the Hobolink data table based on the given \"export\" name. See flagging_site/data/hobolink.py for details. get_live_usgs_data ( () -> pd.DataFrame ): Gets the USGS data table. See flagging_site/data/usgs.py for details. get_data ( () -> pd.DataFrame ): Gets the Hobolink and USGS data tables and returns a combined table. process_data ( (pd.DataFrame, pd.DataFrame) -> pd.DataFrame ): Combines the Hobolink and USGS tables. See flagging_site/data/model.py for details. To add more functions and variables, simply add an entry to the dictionary returned by the function make_shell_context() in flagging_site/app.py:creat_app() .","title":"Available Shell Functions and Variables"},{"location":"shell/#running-the-shell","text":"First, open up a terminal at the flagging folder. Make sure you have Python 3 installed. Set up your environment with the following commands: python3 -m venv venv source venv/bin/activate python3 -m pip install -r requirements.txt Export the following environment variables like so: export VAULT_PASSWORD = replace_me_with_pw export FLASK_APP = flagging_site:create_app export FLASK_ENV = development Finally, start the Flask shell: flask shell And you should be good to go! The functions listed above should be available for use. See below for an example.","title":"Running the Shell"},{"location":"shell/#example-export-hobolink-data-to-csv","text":"Here we assume you have already started the Flask shell. This example shows how to download the Hobolink data and save it as a CSV file. >>> hobolink_data = get_live_hobolink_data () >>> hobolink_data . to_csv ( 'path/where/to/save/my-CSV-file.csv' )","title":"Example: Export Hobolink Data to CSV"},{"location":"system/","text":"Website Explained Diagram Explanation Here is a tentative explanantion of how the website works. Currently it is a flask web application that creates a main web application using create_app() function and retrieve configuration options from config.py and keys from the vault.zip . Then joins mini web apps by registering blueprints found inside the blueprints directory. Particularly the main web app will be joining web app flagging.py to retrieve data from USGS and Hobolink api. With this information, we generate predictive data based on multiple logistic models to determine if river is safe or not. The website displays that data calling render_template() which renders output_model.html with the Jinja template engine. Moreover, we save that data inside a SQL database hosted in heroku, which will also where we deploy the flask web application.","title":"System"},{"location":"system/#website-explained","text":"","title":"Website Explained"},{"location":"system/#diagram","text":"","title":"Diagram"},{"location":"system/#explanation","text":"Here is a tentative explanantion of how the website works. Currently it is a flask web application that creates a main web application using create_app() function and retrieve configuration options from config.py and keys from the vault.zip . Then joins mini web apps by registering blueprints found inside the blueprints directory. Particularly the main web app will be joining web app flagging.py to retrieve data from USGS and Hobolink api. With this information, we generate predictive data based on multiple logistic models to determine if river is safe or not. The website displays that data calling render_template() which renders output_model.html with the Jinja template engine. Moreover, we save that data inside a SQL database hosted in heroku, which will also where we deploy the flask web application.","title":"Explanation"},{"location":"development/history/","text":"Traditionally, the CRWA Flagging Program was hosted on a PHP-built website that hosted a predictive model and ran it. However, that website was out of commission due to some bugs and the CRWA's lack of PHP development resources. We at Code for Boston attempted to fix the website, although we have had trouble maintaining a steady stream of PHP expertise, so we rebuilt the website from scratch in Python. The project's source code is available on GitHub , and the docs we used for project management and some dev stuff are available in the repo's wiki . Why Python? Python proves to be an excellent choice for the development of this website. Due to how the CRWA tends to staff its team (academics and scientists), Python is the most viable language that a website can be built in while still being maintainable by the CRWA. The two most popular coding languages in academia are R and Python. You can't really build a website in R (you technically can, but really really shouldn't for a lot of reasons). So the next best option is Python. Even if the CRWA does not staff people based on their Python knowledge (we do not expect that they will do this), they are very likely have connections to various people who know Python. It is unlikely that the CRWA will have as many direct ties to people who have Javascript or PHP knowledge. Because long-term maintainability is such a high priority, Python is the sensible technical solution. Not only is Python way more popular than PHP in academia, it's the most popular programming language in general . This means that Python is a natural fit for any organization's coding projects that do not have specialized needs for a particular coding language. Why Flask? Once we have decided on Python for web development, we need to make a determination on whether to use Django or Flask, the two leading frameworks for building websites in Python. Django is designed for much more complicated websites than what we would be building. Django has its own idiom that takes a lot of time to learn and get used to. On the other hand, Flask is a very simple and lightweight framework built mainly around the use of its \" app.route() \" decorator. Why Heroku? Heroku's main advantage is that we can run it for free; the CRWA does not want to spend money if they can avoid doing so. One alternative was Google Cloud , specifically the Google App Engine . We did not do this mainly as it is more work to set up for developers and controlling costs requires extra care. E.g. the always free tier of Google Cloud still requires users to plug in a payment method. Developers who want to test Google Cloud functionality would also run into some of those limitations too, depending on their past history with Google Cloud. With that said, Heroku does provide some excellent benefits focused around how lightweight it is. Google Cloud is not shy about the fact that it can host massive enterprise websites with extremely complicated infrastructural needs. Don't get me wrong: Heroku can host large websites too. But Heroku supports small to medium sites extremely well, and it is really nice for open source websites in particular. Heroku is less opinionated about how you manage your website, whereas Google Cloud products tend to push you toward Google's various Python integrations and APIs. Google Cloud is a behemoth of various services that can overwhelm users, whereas Heroku is conceptually easier to understand. Heroku integrates much more nicely into Flask's extensive use of CLIs. For example, Heroku's task scheduler tool (which is very easy to set up) can simply run a command line script built in Flask. Google App Engine lets you do a simple cron job setup that sends GET requests to your app , but doing something that doesn't publicly expose the interface requires use of three additional services : Pub/Sub, Firestore, and Cloud Scheduler. We want to publicly host this website, but we don't want to expose the keys we use for various things. This is a bit easier to do with Heroku, as it has the concept of an environment that lives on the instance's memory and can be set through the CLI. Google App Engine lets you configure the environment only through app.yaml , which is an issue because it means we'd need to gitignore the app.yaml . (We want to just gitignore the keys, not the whole cloud deployment config!) Warning If you ever want to run this website on Google App Engine, you'll have to make some changes to the repository (such as adding an app.yaml ) and may also involve making changes to the code-- mainly the data backend and the task scheduler interface.","title":"History"},{"location":"development/history/#why-python","text":"Python proves to be an excellent choice for the development of this website. Due to how the CRWA tends to staff its team (academics and scientists), Python is the most viable language that a website can be built in while still being maintainable by the CRWA. The two most popular coding languages in academia are R and Python. You can't really build a website in R (you technically can, but really really shouldn't for a lot of reasons). So the next best option is Python. Even if the CRWA does not staff people based on their Python knowledge (we do not expect that they will do this), they are very likely have connections to various people who know Python. It is unlikely that the CRWA will have as many direct ties to people who have Javascript or PHP knowledge. Because long-term maintainability is such a high priority, Python is the sensible technical solution. Not only is Python way more popular than PHP in academia, it's the most popular programming language in general . This means that Python is a natural fit for any organization's coding projects that do not have specialized needs for a particular coding language.","title":"Why Python?"},{"location":"development/history/#why-flask","text":"Once we have decided on Python for web development, we need to make a determination on whether to use Django or Flask, the two leading frameworks for building websites in Python. Django is designed for much more complicated websites than what we would be building. Django has its own idiom that takes a lot of time to learn and get used to. On the other hand, Flask is a very simple and lightweight framework built mainly around the use of its \" app.route() \" decorator.","title":"Why Flask?"},{"location":"development/history/#why-heroku","text":"Heroku's main advantage is that we can run it for free; the CRWA does not want to spend money if they can avoid doing so. One alternative was Google Cloud , specifically the Google App Engine . We did not do this mainly as it is more work to set up for developers and controlling costs requires extra care. E.g. the always free tier of Google Cloud still requires users to plug in a payment method. Developers who want to test Google Cloud functionality would also run into some of those limitations too, depending on their past history with Google Cloud. With that said, Heroku does provide some excellent benefits focused around how lightweight it is. Google Cloud is not shy about the fact that it can host massive enterprise websites with extremely complicated infrastructural needs. Don't get me wrong: Heroku can host large websites too. But Heroku supports small to medium sites extremely well, and it is really nice for open source websites in particular. Heroku is less opinionated about how you manage your website, whereas Google Cloud products tend to push you toward Google's various Python integrations and APIs. Google Cloud is a behemoth of various services that can overwhelm users, whereas Heroku is conceptually easier to understand. Heroku integrates much more nicely into Flask's extensive use of CLIs. For example, Heroku's task scheduler tool (which is very easy to set up) can simply run a command line script built in Flask. Google App Engine lets you do a simple cron job setup that sends GET requests to your app , but doing something that doesn't publicly expose the interface requires use of three additional services : Pub/Sub, Firestore, and Cloud Scheduler. We want to publicly host this website, but we don't want to expose the keys we use for various things. This is a bit easier to do with Heroku, as it has the concept of an environment that lives on the instance's memory and can be set through the CLI. Google App Engine lets you configure the environment only through app.yaml , which is an issue because it means we'd need to gitignore the app.yaml . (We want to just gitignore the keys, not the whole cloud deployment config!) Warning If you ever want to run this website on Google App Engine, you'll have to make some changes to the repository (such as adding an app.yaml ) and may also involve making changes to the code-- mainly the data backend and the task scheduler interface.","title":"Why Heroku?"},{"location":"development/setup/","text":"Requirements Python 3 , specifically 3.7 or higher. Postgres (see installation instructions below) (OSX only) Homebrew Postgres installation Installing Postgres Windows (CMD) Download here and install via the executable. (If you had any terminals open, close out and reopen after Postgres installation.) Open command prompt and try the following (case-sensitive): psql -V If it returns the version number then you're set. If you get an error about the command not being recognized, then it might mean you need to manually add Postgres's bin to your PATH ( see here ). OSX (Bash) If you do not have Homebrew installed, install it from here . Via a bash terminal: brew install postgres Test that it works by running (case-sensitive): psql -V . If it returns the version number then you're set. Tip Chances are you are not going to need Postgres to run in the background constantly, so you should learn how to turn it off and back on. Windows (CMD) Turn Postgres on/off: Go to the Start menu and open up \"Run...\" services.msc -> Enter. This opens the Services panel. Look for the name postgresql and start/stop Postgres. Keep Postgres from running at startup: (Via the Services panel) As long as the service is \"manual\" and not automatic, it will not load at startup. OSX (Bash) Turn Postgres on: pg_ctl -D /usr/local/var/postgres start Turn Postgres back off: pg_ctl -D /usr/local/var/postgres stop Keep Postgres from running at startup: Some solutions here .","title":"Requirements"},{"location":"development/setup/#requirements","text":"Python 3 , specifically 3.7 or higher. Postgres (see installation instructions below) (OSX only) Homebrew","title":"Requirements"},{"location":"development/setup/#postgres-installation","text":"Installing Postgres Windows (CMD) Download here and install via the executable. (If you had any terminals open, close out and reopen after Postgres installation.) Open command prompt and try the following (case-sensitive): psql -V If it returns the version number then you're set. If you get an error about the command not being recognized, then it might mean you need to manually add Postgres's bin to your PATH ( see here ). OSX (Bash) If you do not have Homebrew installed, install it from here . Via a bash terminal: brew install postgres Test that it works by running (case-sensitive): psql -V . If it returns the version number then you're set. Tip Chances are you are not going to need Postgres to run in the background constantly, so you should learn how to turn it off and back on. Windows (CMD) Turn Postgres on/off: Go to the Start menu and open up \"Run...\" services.msc -> Enter. This opens the Services panel. Look for the name postgresql and start/stop Postgres. Keep Postgres from running at startup: (Via the Services panel) As long as the service is \"manual\" and not automatic, it will not load at startup. OSX (Bash) Turn Postgres on: pg_ctl -D /usr/local/var/postgres start Turn Postgres back off: pg_ctl -D /usr/local/var/postgres stop Keep Postgres from running at startup: Some solutions here .","title":"Postgres installation"}]}